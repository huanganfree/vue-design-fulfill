<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>设计完善的响应式系统</title>
</head>

<body>

    <script>
        // 1.初版
        // 初版的问题在于：对象的任何属性操作，都会触发副作用函数执行
        function originalVersion() {
            const bucket = new Set()

            const data = {text: 'hello world'}

            let activeEffect = null

            const obj = new Proxy(data, {
                get(target, key) {
                    if (activeEffect) {
                        bucket.add(activeEffect)
                    }
                    return target[key]
                },
                set(target, key, newVal) {
                    target[key] = newVal
                    bucket.forEach(fn => fn())
                    return true
                }
            })

            function effect(fn) {
                activeEffect = fn
                fn()
            }
            effect(
                () => document.body.innerText = obj.text + '--'
            )

            setTimeout(() => {
                console.log(111);
                obj.text11 = '22'
            }, 1000);
        }

        // 2.不同对象的不同属性和副作用函数之间建立对应关系
        // 封装收集副作用函数的逻辑
        function track(objMap, target, key, activeEffect) {
            let keyMap = objMap.get(target)
            if (!keyMap) {
                keyMap = new Map()
                objMap.set(target, keyMap) // 建立映射关系
            }

            let effectFnSet = keyMap.get(key)

            if (!effectFnSet) {
                effectFnSet = new Set()
                keyMap.set(key, effectFnSet) // key的值是set集合，因为副作用函数不止一个
            }
            effectFnSet.add(activeEffect)
            activeEffect.deps.push(effectFnSet)
            // 以下方法多余，因为set不会重复添加的。
            // const aimFn = [...effectFnSet].find(fn => fn == activeEffect)
            // if (!aimFn) { // 在set的桶中，没找到函数
            //     effectFnSet.add(activeEffect)
            // }
        }
        // 封装执行依赖集合中副作用函数的逻辑
        function trigger(objMap, target, key) {
            const keyMap = objMap.get(target)
            if (!keyMap) {
                return
            }
            const effectFnSet = keyMap.get(key)
            if (effectFnSet) {
                effectFnSet.forEach(fn => fn())
            }
        }
        function secondVersion() {

            const objMap = new Map() // 存储对象和key的映射关系

            const data = {text: 'hello world', ok: true}

            let activeEffect = null
            const obj = new Proxy(data, {
                get(target, key) {
                    track(objMap, target, key, activeEffect)
                    return target[key]
                },
                set(target, key, newVal) {
                    target[key] = newVal
                    trigger(objMap, target, key)
                    return true
                }
            })

            function effect(fn) {
                activeEffect = fn
                fn()
            }

            const fnl = function () {
                console.log(111);
                document.body.innerText = obj.ok ? obj.text : 'not'
            }


            effect(fnl)

            console.log(objMap);
            setTimeout(() => {
                obj.ok = false
                setTimeout(() => {
                    obj.text = 1122
                }, 1000);
            }, 1000);

        }

        /**
         * 3. 第二点中也有不太严谨的逻辑，就是ok属性如果变为false。然后，text变化时，副作用函数仍执行。我们希望不读取
         *  text值时，是不存储副作用函数的。
        */
        thirdVersion()
        function thirdVersion() {
            let activeEffect = null
            const objMap = new Map() // 存储对象和key的映射关系

            const data = { text: 'hello world', ok: true }

            const obj = new Proxy(data, {
                get(target, key) {
                    track(objMap, target, key, activeEffect)
                    return target[key]
                },
                set(target, key, newVal) {
                    target[key] = newVal
                    trigger(objMap, target, key)
                    return true
                }
            })

            function effect(fn) {
                const effectTruth = () => {
                    cleanup(activeEffect)
                    fn()
                }
                activeEffect = effectTruth
                activeEffect.deps = []
                effectTruth(activeEffect)
            }

            function cleanup(activeEffect) {
                activeEffect.deps.forEach(depSet => {
                    depSet.delete(activeEffect)
                })
                activeEffect.deps = []
            }

            const fnl = function (selfFn)  {
                console.log('fnl---');
                document.body.innerText = obj.ok ? obj.text : 'not'
            }

            effect(fnl)

            setTimeout(() => {
                obj.ok = false
                setTimeout(() => {
                    obj.text = 1122
                }, 1000);
            }, 1000);

        }

    </script>

</body>

</html>